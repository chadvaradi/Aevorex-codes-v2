import ast
from pathlib import Path
from typing import List, Dict

HEADER_TEMPLATE = """# backend/core/{package_name}/__init__.py
# ==============================================================================
# Public Interface for the {package_name_title} Package (v4.1 - Auto-generated)
# ==============================================================================
#
# This file is auto-generated by a script. Do not edit manually.
#
# It uses a dynamic, map-based approach to import and export all primary data
# mapping functions from provider-specific sub-packages.
#
# ==============================================================================

import logging
from typing import List, Dict, Any
from collections.abc import Callable
import importlib

try:
    from ...utils.logger_config import get_logger
    logger = get_logger("aevorex_finbot.core.{package_name}")
except ImportError:
    logging.basicConfig(level=logging.WARNING)
    logger = logging.getLogger("aevorex_finbot.core.{package_name}.fallback")
    logger.warning("Using fallback logger for {package_name} package.")

"""

MODULE_MAP_TEMPLATE = """
# --- Dynamic Module and Function Mapping ---
MODULE_MAP: Dict[str, List[str]] = {package_map}
"""

FOOTER_TEMPLATE = """
_available_functions: dict[str, Callable[..., Any]] = {}

logger.info("Initializing {package_name} package (v4.1 - auto-generated)...")

for module_path, func_list in MODULE_MAP.items():
    try:
        module = importlib.import_module(module_path, package=__package__)
        logger.debug(f"Successfully loaded module: '{{module_path}}'")

        for func_spec in func_list:
            original_name, alias_name = (
                [s.strip() for s in func_spec.split(' as ')]
                if ' as ' in func_spec
                else (func_spec, func_spec)
            )

            try:
                target_func = getattr(module, original_name)
                if callable(target_func):
                    globals()[alias_name] = target_func
                    _available_functions[alias_name] = target_func
                    logger.debug(f"  -> Exported '{{alias_name}}' from '{{module_path}}'")
                else:
                    logger.warning(f"Attribute '{{original_name}}' in '{{module_path}}' is not callable.")
            except AttributeError:
                logger.error(f"Function '{{original_name}}' not found in module '{{module_path}}'.")

    except ImportError as e:
        logger.error(f"Failed to import module '{{module_path}}': {{e}}")
    except Exception as e:
        logger.error(f"An unexpected error occurred loading from '{{module_path}}': {{e}}", exc_info=True)


__all__ = sorted(list(_available_functions.keys()))

logger.info(
    "{package_name_title} package initialized. Exposed functions (%d): %s",
    len(__all__),
    ', '.join(__all__) if __all__ else 'None'
)
"""

def get_public_functions(filepath: Path) -> List[str]:
    """Parses a Python file and returns a list of public function names."""
    with open(filepath, 'r', encoding='utf-8') as f:
        content = f.read()
    
    tree = ast.parse(content)
    functions = []
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and not node.name.startswith('_'):
            functions.append(node.name)
        elif isinstance(node, ast.AsyncFunctionDef) and not node.name.startswith('_'):
            functions.append(node.name)
    return functions

def generate_module_map(package_dir: Path) -> Dict[str, List[str]]:
    """Generates the MODULE_MAP for a given package directory."""
    module_map = {}
    for provider_dir in package_dir.iterdir():
        if provider_dir.is_dir() and (provider_dir / '__init__.py').exists():
            provider_name = provider_dir.name
            module_path = f".{provider_name}"
            functions = []
            for py_file in provider_dir.glob('*.py'):
                if py_file.name == '__init__.py' or py_file.name.startswith('_'):
                    continue
                functions.extend(get_public_functions(py_file))
            if functions:
                module_map[module_path] = sorted(list(set(functions)))
    return module_map

def format_module_map(module_map: Dict[str, List[str]]) -> str:
    """Formats the module map dictionary into a string for the template."""
    import json
    # Pretty print the dictionary using json.dumps for nice formatting
    formatted_map = json.dumps(module_map, indent=4)
    # Add a trailing comma to the last item in each list for cleaner diffs
    formatted_map = formatted_map.replace('"\n    ]', '",\n    ]')
    return formatted_map


def main():
    """Main function to regenerate __init__.py files."""
    base_dir = Path("modules/financehub/backend/core")
    packages_to_scan = ["mappers", "fetchers"]

    for package_name in packages_to_scan:
        package_dir = base_dir / package_name
        init_file = package_dir / "__init__.py"
        package_name_title = package_name.capitalize()

        print(f"--- Regenerating for '{package_name}' ---")
        
        if not package_dir.is_dir():
            print(f"❌ Directory not found: {package_dir}")
            continue

        print(f"Scanning subdirectories in: {package_dir}")
        module_map = generate_module_map(package_dir)
        
        # Special handling for mappers' _shared module
        if package_name == "mappers":
            shared_file = package_dir / "_shared_mappers.py"
            if shared_file.exists():
                shared_functions = get_public_functions(shared_file)
                module_map["._shared"] = shared_functions
        
        formatted_map = format_module_map(module_map)

        print(f"Generated MODULE_MAP for {package_name}:")
        print(formatted_map)

        header = HEADER_TEMPLATE.format(package_name=package_name, package_name_title=package_name_title)
        map_section = MODULE_MAP_TEMPLATE.format(package_map=formatted_map)
        
        # Here we manually format the last part of the footer to avoid f-string issues
        footer_static_part = FOOTER_TEMPLATE.split("{package_name_title}")[0]
        footer_dynamic_part = FOOTER_TEMPLATE.split("): %s")[1]
        
        footer = footer_static_part + package_name_title + " package initialized. Exposed functions (%d): %s" + footer_dynamic_part

        full_content = header + map_section + footer
        
        print(f"Writing new content to: {init_file}")
        with open(init_file, 'w', encoding='utf-8') as f:
            f.write(full_content)
        
        print(f"✅ Successfully regenerated {init_file}")
        print("-" * 20)

if __name__ == "__main__":
    main() 